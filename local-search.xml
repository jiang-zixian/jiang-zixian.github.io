<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>利用VAE做异常检测</title>
    <link href="/2025/11/21/%E5%88%A9%E7%94%A8VAE%E5%81%9A%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/"/>
    <url>/2025/11/21/%E5%88%A9%E7%94%A8VAE%E5%81%9A%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="利用VAE做异常检测"><a href="#利用VAE做异常检测" class="headerlink" title="利用VAE做异常检测"></a>利用VAE做异常检测</h1><p>使用 <strong>VAE（Variational Autoencoder，变分自编码器）做异常检测</strong> 的核心原理可以总结为一句话：</p><blockquote><p><strong>VAE 在正常数据上学习到一个概率生成模型，能够高概率地重建正常样本；而异常样本偏离正常数据分布，在 VAE 中会表现为重建差、低似然或潜变量分布不合理，因此可以被检测出来。</strong></p></blockquote><hr><h1 id="1-VAE-做异常检测的基本机制（核心原理）"><a href="#1-VAE-做异常检测的基本机制（核心原理）" class="headerlink" title="1. VAE 做异常检测的基本机制（核心原理）"></a>1. VAE 做异常检测的基本机制（核心原理）</h1><p>VAE 是一个概率生成模型，由两个网络组成：</p><ul><li><strong>Encoder</strong>：把输入 (x) 映射到潜变量分布 $(q_\phi(z|x))$（通常是高斯分布的均值和方差）。</li><li><strong>Decoder</strong>：从潜变量 (z) 生成重建样本 $(\hat{x} &#x3D; p_\theta(x|z))$。</li></ul><p>训练目标是最大化“证据下界”（ELBO）：</p><p>[<br>\log p_\theta(x) \ge \mathbb{E}_{q_\phi(z|x)}[\log p_\theta(x|z)] - KL\big(q_\phi(z|x) ,|, p(z)\big)<br>]</p><p>➡ <strong>VAE 本质是在学习“正常数据的概率分布”</strong>。</p><hr><h2 id="在异常检测中，它的逻辑是："><a href="#在异常检测中，它的逻辑是：" class="headerlink" title="在异常检测中，它的逻辑是："></a>在异常检测中，它的逻辑是：</h2><ol><li><p><strong>训练阶段：</strong></p><ul><li>用<strong>正常样本</strong>训练 VAE。</li><li>VAE 会把“正常样本的潜在空间结构”学得很好。</li><li>异常模式因为没出现过 → VAE 不会学到它们。</li></ul></li><li><p><strong>测试阶段：</strong></p><ul><li>对输入数据 (x) 使用训练好的 VAE 进行编码和重建。</li><li>判断这个 (x) 是否“符合正常分布”。</li></ul></li></ol><hr><h1 id="2-如何判断异常？（三种常见指标）"><a href="#2-如何判断异常？（三种常见指标）" class="headerlink" title="2. 如何判断异常？（三种常见指标）"></a>2. 如何判断异常？（三种常见指标）</h1><h2 id="①-重建误差（Reconstruction-Error）"><a href="#①-重建误差（Reconstruction-Error）" class="headerlink" title="① 重建误差（Reconstruction Error）"></a><strong>① 重建误差（Reconstruction Error）</strong></h2><p>[<br>| x - \hat{x} |<br>]</p><ul><li>对正常样本：VAE 学得很好 → 重建误差小</li><li>对异常样本：VAE 不知道如何生成 → 重建误差大</li></ul><p>➡ 最常见的异常检测方法。</p><hr><h2 id="②-重建概率-负对数似然（NLL）"><a href="#②-重建概率-负对数似然（NLL）" class="headerlink" title="② 重建概率 &#x2F; 负对数似然（NLL）"></a><strong>② 重建概率 &#x2F; 负对数似然（NLL）</strong></h2><p>VAE 本质是概率生成模型，所以可以计算：</p><p>[<br>-\log p_\theta(x|z)<br>]</p><ul><li>正常：似然高 → NLL 小</li><li>异常：似然低 → NLL 大</li></ul><p>➡ <strong>比简单重建误差更稳健</strong>。</p><hr><h2 id="③-潜变量分布偏差（KL-Divergence）"><a href="#③-潜变量分布偏差（KL-Divergence）" class="headerlink" title="③ 潜变量分布偏差（KL Divergence）"></a><strong>③ 潜变量分布偏差（KL Divergence）</strong></h2><p>[<br>KL\big(q_\phi(z|x) ,|, p(z)\big)<br>]</p><p>其中 (p(z)) 是先验（通常是标准正态分布）。</p><ul><li>正常样本：潜变量落在 VAE 习惯的区域 → KL 小</li><li>异常样本：潜变量分布很奇怪 → KL 大</li></ul><p>➡ 常用于工业数据监控&#x2F;传感器异常检测。</p><hr><h1 id="3-VAE-为什么能检测异常？（直观理解）"><a href="#3-VAE-为什么能检测异常？（直观理解）" class="headerlink" title="3. VAE 为什么能检测异常？（直观理解）"></a>3. VAE 为什么能检测异常？（直观理解）</h1><h2 id="核心理由：VAE-的能力是有限的，它只能很好表示“被训练过的数据”。"><a href="#核心理由：VAE-的能力是有限的，它只能很好表示“被训练过的数据”。" class="headerlink" title="核心理由：VAE 的能力是有限的，它只能很好表示“被训练过的数据”。"></a><strong>核心理由：VAE 的能力是有限的，它只能很好表示“被训练过的数据”。</strong></h2><h3 id="对正常数据："><a href="#对正常数据：" class="headerlink" title="对正常数据："></a>对正常数据：</h3><ul><li>学到了对应的潜变量结构</li><li>解码器能从潜空间正确“生成”正常样本</li><li>因此重建误差小 &#x2F; 似然高</li></ul><h3 id="对异常数据："><a href="#对异常数据：" class="headerlink" title="对异常数据："></a>对异常数据：</h3><ul><li>这些样本分布不在训练分布内</li><li>Encoder 会把它们映射到一个异常的 latent region（潜空间没有见过）</li><li>Decoder 不能按照正常方式“重建”它们</li><li>因此重建误差变大或似然变低</li></ul><hr><h1 id="4-VAE-异常检测的局限性（非常重要）"><a href="#4-VAE-异常检测的局限性（非常重要）" class="headerlink" title="4. VAE 异常检测的局限性（非常重要）"></a>4. VAE 异常检测的局限性（非常重要）</h1><ol><li><p><strong>重建能力太强时，会“重建异常” → 导致漏检</strong><br>（比如 β-VAE 等可控制 KL 的 VAE 能部分缓解）</p></li><li><p><strong>潜空间过于简单（如高斯先验）可能限制表达能力</strong></p></li><li><p><strong>需要大量“纯净的正常样本”</strong><br>如果训练集中混入异常 → 性能显著下降</p></li><li><p><strong>高维数据（视频）可能重建误差难以界定</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决无法连接huggingface问题</title>
    <link href="/2025/11/13/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5huggingface%E9%97%AE%E9%A2%98/"/>
    <url>/2025/11/13/%E8%A7%A3%E5%86%B3%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5huggingface%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>当写代码总是连接不上huggingface、无法拉模型和数据集的时候，可以用以下方法提前把模型和数据集拉到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://hf-mirror.com/hfd/hfd.sh<br><span class="hljs-built_in">chmod</span> a+x hfd.sh<br><br><span class="hljs-comment"># Linux环境下：</span><br><span class="hljs-built_in">export</span> HF_ENDPOINT=https://hf-mirror.com<br><br><span class="hljs-comment"># Windows Powershell</span><br><span class="hljs-variable">$env</span>:HF_ENDPOINT =<span class="hljs-string">&quot;https://hf-mirror.com&quot;</span><br><br><span class="hljs-comment"># download model to current dir</span><br>../hfd.sh Lemhf14/EasyJailbreak_Datasets --hf_username *** --hf_token ***<br><br><span class="hljs-comment"># download dataset to current dir</span><br>../hfd.sh Lemhf14/EasyJailbreak_Datasets --hf_username *** --hf_token *** --dataset<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mac运行传感器脆弱性生成式检测系统步骤</title>
    <link href="/2025/10/11/mac%E8%BF%90%E8%A1%8C%E4%BC%A0%E6%84%9F%E5%99%A8%E8%84%86%E5%BC%B1%E6%80%A7%E7%94%9F%E6%88%90%E5%BC%8F%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E6%AD%A5%E9%AA%A4/"/>
    <url>/2025/10/11/mac%E8%BF%90%E8%A1%8C%E4%BC%A0%E6%84%9F%E5%99%A8%E8%84%86%E5%BC%B1%E6%80%A7%E7%94%9F%E6%88%90%E5%BC%8F%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<p>本笔记作试验记录用</p><h1 id="mac启动sensecllm步骤"><a href="#mac启动sensecllm步骤" class="headerlink" title="mac启动sensecllm步骤"></a>mac启动sensecllm步骤</h1><h2 id="启动dify"><a href="#启动dify" class="headerlink" title="启动dify"></a>启动dify</h2><h3 id="后台启动docker"><a href="#后台启动docker" class="headerlink" title="后台启动docker"></a>后台启动docker</h3><h3 id="启动dify-1"><a href="#启动dify-1" class="headerlink" title="启动dify"></a>启动dify</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /Users/jiangzixian/jzx-work/dify-main/docker<br>docker-compose up -d<br></code></pre></td></tr></table></figure><h2 id="启动sensecllm"><a href="#启动sensecllm" class="headerlink" title="启动sensecllm"></a>启动sensecllm</h2><p>源码在文件夹<code>/Users/jiangzixian/Nutstore Files/FILE_ALL/博一/2025-毕设jzx/具体工作/SenSecLLM部署/tot</code></p><p>之后进入your_env_name的conda环境</p><p>启动<code>deepseek-v3-PromptChaining-table-new-mac.py</code>文件即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>实践技术</tag>
      
      <tag>传感器脆弱性生成式检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows11:Docker Desktop修改镜像下载路径（Disk image location）</title>
    <link href="/2025/01/21/Windows11-Docker-Desktop%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD%E8%B7%AF%E5%BE%84%EF%BC%88Disk-image-location%EF%BC%89/"/>
    <url>/2025/01/21/Windows11-Docker-Desktop%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD%E8%B7%AF%E5%BE%84%EF%BC%88Disk-image-location%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>操作系统：windows11</p><p>步骤：</p><ol><li>打开Docker Desktop</li><li>点击右上角设置<br><img src="/../img/image.png" alt="alt text"></li><li>Resources-&gt;Disk image location-&gt;Apply&amp;restart<br><img src="/../img/image-1.png" alt="alt text"></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实践技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Langchain-Chatchat(0.2.x)本地轻量化部署+在线大模型api</title>
    <link href="/2025/01/21/Langchain-Chatchat-0-2-x-%E6%9C%AC%E5%9C%B0%E8%BD%BB%E9%87%8F%E5%8C%96%E9%83%A8%E7%BD%B2-%E5%9C%A8%E7%BA%BF%E5%A4%A7%E6%A8%A1%E5%9E%8Bapi/"/>
    <url>/2025/01/21/Langchain-Chatchat-0-2-x-%E6%9C%AC%E5%9C%B0%E8%BD%BB%E9%87%8F%E5%8C%96%E9%83%A8%E7%BD%B2-%E5%9C%A8%E7%BA%BF%E5%A4%A7%E6%A8%A1%E5%9E%8Bapi/</url>
    
    <content type="html"><![CDATA[<p>感谢这位大佬的<a href="https://blog.csdn.net/YELLOWAUG/article/details/136241731">部署笔记</a>，我在此基础上做出一些说明和补充</p><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>操作系统：windows 11<br>需提前下载：</p><ul><li>Docker Desktop</li><li>python 3.11.x，我用的3.11.11</li><li>线上大模型api key的获取，本人暂时只获取了zhipu-api</li></ul><h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><h3 id="docker拉取官方python-3-11的镜像"><a href="#docker拉取官方python-3-11的镜像" class="headerlink" title="docker拉取官方python 3.11的镜像"></a>docker拉取官方python 3.11的镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull python:3.11<br></code></pre></td></tr></table></figure><blockquote><p>Docker Desktop默认的镜像下载地址在C盘，建议将镜像默认下载地址放到非C盘，以防C盘爆满，具体操作见<a href="/2025/01/21/Windows11-Docker-Desktop%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD%E8%B7%AF%E5%BE%84%EF%BC%88Disk-image-location%EF%BC%89/" title="Windows11:Docker Desktop修改镜像下载路径（Disk image location）">Windows11:Docker Desktop修改镜像下载路径（Disk image location）</a></p></blockquote><h3 id="运行Docker容器"><a href="#运行Docker容器" class="headerlink" title="运行Docker容器"></a>运行Docker容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -itd --name chatlite -v /etc/localtime:/etc/localtime:ro -p 18501:8501 python:3.11<br></code></pre></td></tr></table></figure><h3 id="下载Langchain-Chatchat-0-2-x项目源码"><a href="#下载Langchain-Chatchat-0-2-x项目源码" class="headerlink" title="下载Langchain-Chatchat 0.2.x项目源码"></a>下载Langchain-Chatchat 0.2.x项目源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> -b 0.2.final --recursive https://github.com/chatchat-space/Langchain-Chatchat.git<br></code></pre></td></tr></table></figure><blockquote><p>这里指定0.2.final分支，不使用最新的0.3.x版本，本人暂时未成功部署0.3.x</p></blockquote><h3 id="Langchain-Chatchat源码修改"><a href="#Langchain-Chatchat源码修改" class="headerlink" title="Langchain-Chatchat源码修改"></a>Langchain-Chatchat源码修改</h3><ol><li><p>根目录下config文件夹下面的文件格式原本为*.py.example, 要全部改成.py，修改后如下<br><img src="/../img/image-2.png" alt="alt text"></p></li><li><p>修改根目录下的configs&#x2F;model_config.py配置文件<br>修改三个地方：</p></li></ol><ul><li>“LLM_MODELS”<br>  修改为 LLM_MODELS &#x3D; [“zhipu-api”, “openai-api”]<blockquote><p>想要使用什么其他的api，在后面添加即可</p></blockquote></li><li>“LLM_DEVICE”<br>  修改为 LLM_DEVICE &#x3D; “cpu”<blockquote><p>我们在LLM_MODELS 这个字段里把线下的大模型给删除了，这样程序在加载模型的时候就不会加载本地模型了。只要不加载本地LLM模型，就不会有对GPU的计算需求，LLM_DEVICE 这个字段改成“CPU” 目的是让模型加载方式是用CPU加载。</p></blockquote></li><li>“zhipu-api”<br>  要补充自己的api key（分别上官网获取）<br>  <img src="/../img/image-3.png" alt="alt text"><blockquote><p>想要使用什么api，自行填充对应的key即可，本人暂时只获取了zhipu-api</p></blockquote></li></ul><h3 id="将项目文件夹copy到容器中"><a href="#将项目文件夹copy到容器中" class="headerlink" title="将项目文件夹copy到容器中"></a>将项目文件夹copy到容器中</h3><p>容器ID在docker run之后用docker ps指令获取即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> ./Langchain-Chatchat-2 容器ID:/home <br></code></pre></td></tr></table></figure><h3 id="进入容器终端-进入项目目录"><a href="#进入容器终端-进入项目目录" class="headerlink" title="进入容器终端,进入项目目录"></a>进入容器终端,进入项目目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it 容器ID /bin/bash<br><span class="hljs-built_in">cd</span> /home/Langchain-Chatchat-2<br></code></pre></td></tr></table></figure><h3 id="下载依赖"><a href="#下载依赖" class="headerlink" title="下载依赖"></a>下载依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements_lite.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/<br><br>pip install -r requirements_webui.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/<br></code></pre></td></tr></table></figure><h3 id="启动Langchain-Chatchat（只运行线上LLM-API的方式）"><a href="#启动Langchain-Chatchat（只运行线上LLM-API的方式）" class="headerlink" title="启动Langchain-Chatchat（只运行线上LLM API的方式）"></a>启动Langchain-Chatchat（只运行线上LLM API的方式）</h3><p>要在项目的根目录下运行该命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python startup.py -a --lite<br></code></pre></td></tr></table></figure><p>注意：启动过程中，会报以下类似错误：<br><img src="/../img/image-4.png" alt="alt text"><br>只是因为缺少了一些依赖，我们使用pip install单独下载即可，比如对于上述错误，我们只需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install markdownify<br></code></pre></td></tr></table></figure><h3 id="启动成功"><a href="#启动成功" class="headerlink" title="启动成功"></a>启动成功</h3><p>终端显示：<br><img src="/../img/image-5.png" alt="alt text"></p><p>访问该URL即可</p><p><img src="/../img/image-6.png" alt="alt text"></p><h2 id="启动步骤"><a href="#启动步骤" class="headerlink" title="启动步骤"></a>启动步骤</h2><h3 id="启动windows的docker"><a href="#启动windows的docker" class="headerlink" title="启动windows的docker"></a>启动windows的docker</h3><p>打开docker软件即可</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start chatlite<br></code></pre></td></tr></table></figure><h3 id="进入命令行"><a href="#进入命令行" class="headerlink" title="进入命令行"></a>进入命令行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it chatlite bash<br></code></pre></td></tr></table></figure><h3 id="在容器中启动服务"><a href="#在容器中启动服务" class="headerlink" title="在容器中启动服务"></a>在容器中启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/Langchain-Chatchat-2<br>python startup.py -a --lite<br></code></pre></td></tr></table></figure><h3 id="在浏览器里访问"><a href="#在浏览器里访问" class="headerlink" title="在浏览器里访问"></a>在浏览器里访问</h3><p>访问 <code>http://0.0.0.0:8501</code></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实践技术</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用指令</title>
    <link href="/2024/10/12/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/10/12/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="访问git超时时（windows）"><a href="#访问git超时时（windows）" class="headerlink" title="访问git超时时（windows）"></a>访问git超时时（windows）</h2><p>取消系统代理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">git config --global --<span class="hljs-built_in">unset</span> http.proxy <br>git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure><h2 id="npm-network-error问题"><a href="#npm-network-error问题" class="headerlink" title="npm network error问题"></a>npm network error问题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npmmirror.com<br></code></pre></td></tr></table></figure><p>查看npm配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config list<br></code></pre></td></tr></table></figure><h2 id="conda相关常用命令"><a href="#conda相关常用命令" class="headerlink" title="conda相关常用命令"></a>conda相关常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda --version  <span class="hljs-comment">#查看版本</span><br><br>conda create --name myenv python=3.8 <br>conda activate myenv <br>conda deactivate<br>conda remove --name myenv --all <span class="hljs-comment">#删除虚拟环境及其中的所有内容。</span><br><br><span class="hljs-comment"># 查看所有环境</span><br>conda <span class="hljs-built_in">env</span> list<br>    <span class="hljs-comment"># 或者</span><br>conda info --envs<br><br><br><span class="hljs-comment">#包管理</span><br>conda install：安装包<br>conda update：更新包<br>conda remove：卸载包<br>conda list：查看已安装的包<br><span class="hljs-comment">#环境导出与克隆</span><br>conda <span class="hljs-built_in">env</span> <span class="hljs-built_in">export</span>：导出环境配置<br>conda <span class="hljs-built_in">env</span> create：通过环境配置文件创建环境<br>conda list --explicit：导出所有包的精确安装列表<br>conda <span class="hljs-built_in">clone</span>：克隆现有环境<br><span class="hljs-comment">#搜索和查看</span><br>conda search：搜索包<br>conda info：显示环境和配置的详细信息<br><span class="hljs-comment">#其他命令</span><br>conda clean：清理缓存<br>conda config：配置 conda 设置<br>conda package：构建自定义包<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实践技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非C盘安装WSL2</title>
    <link href="/2024/10/11/%E9%9D%9EC%E7%9B%98%E5%AE%89%E8%A3%85WSL2/"/>
    <url>/2024/10/11/%E9%9D%9EC%E7%9B%98%E5%AE%89%E8%A3%85WSL2/</url>
    
    <content type="html"><![CDATA[<h1 id="非C盘安装WSL2"><a href="#非C盘安装WSL2" class="headerlink" title="非C盘安装WSL2"></a>非C盘安装WSL2</h1><h2 id="第一种方法（失败，下载的WSL2不能git-clone）"><a href="#第一种方法（失败，下载的WSL2不能git-clone）" class="headerlink" title="第一种方法（失败，下载的WSL2不能git clone）"></a>第一种方法（失败，下载的WSL2不能git clone）</h2><h3 id="install-WSL2"><a href="#install-WSL2" class="headerlink" title="install WSL2"></a>install WSL2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --install<br>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart<br>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart<br>wsl --set-default-version 2<br></code></pre></td></tr></table></figure><h3 id="uninstall-ubuntu"><a href="#uninstall-ubuntu" class="headerlink" title="uninstall ubuntu"></a>uninstall ubuntu</h3><p>在电脑中直接卸载即可</p><h3 id="install-ubuntu-in-F"><a href="#install-ubuntu-in-F" class="headerlink" title="install ubuntu in F:"></a>install ubuntu in F:</h3><p>win 终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> F:<br><span class="hljs-built_in">mkdir</span> Linux//创建一个linux文件夹<br><span class="hljs-built_in">cd</span> Linux<br>Invoke-WebRequest -Uri https://wsldownload.azureedge.net/Ubuntu_2004.2020.424.0_x64.appx -OutFile Ubuntu20.04.appx -UseBasicParsing//下载ubuntu20.04<br>Rename-Item .\Ubuntu20.04.appx Ubuntu.zip<br>Expand-Archive .\Ubuntu.zip -Verbose<br><span class="hljs-built_in">cd</span> .\Ubuntu\<br>.\ubuntu2004.exe<br></code></pre></td></tr></table></figure><p>之后设置自己的username和password即可</p><h3 id="问题-WSL2-请启用虚拟机平台-Windows-功能并确保在-BIOS-中启用虚拟化"><a href="#问题-WSL2-请启用虚拟机平台-Windows-功能并确保在-BIOS-中启用虚拟化" class="headerlink" title="问题:WSL2 请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化"></a>问题:WSL2 请启用虚拟机平台 Windows 功能并确保在 BIOS 中启用虚拟化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bcdedit /set hypervisorlaunchtype off（之后可用vmware）<br>bcdedit /set hypervisorlaunchtype auto<br></code></pre></td></tr></table></figure><p>之后重启电脑即可</p><h2 id="第二种方法（安装在C盘之后迁移至F盘）"><a href="#第二种方法（安装在C盘之后迁移至F盘）" class="headerlink" title="第二种方法（安装在C盘之后迁移至F盘）"></a>第二种方法（安装在C盘之后迁移至F盘）</h2><h3 id="下载-WSL2"><a href="#下载-WSL2" class="headerlink" title="下载 WSL2"></a>下载 WSL2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --install -d Ubuntu-20.04<br></code></pre></td></tr></table></figure><h3 id="终止正在运行的wsl"><a href="#终止正在运行的wsl" class="headerlink" title="终止正在运行的wsl"></a>终止正在运行的wsl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><h3 id="将需要迁移的Linux，进行导出"><a href="#将需要迁移的Linux，进行导出" class="headerlink" title="将需要迁移的Linux，进行导出"></a>将需要迁移的Linux，进行导出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --<span class="hljs-built_in">export</span> Ubuntu-20.04 F:/export.tar<br></code></pre></td></tr></table></figure><h3 id="导出完成之后，将原有的分发进行卸载"><a href="#导出完成之后，将原有的分发进行卸载" class="headerlink" title="导出完成之后，将原有的分发进行卸载"></a>导出完成之后，将原有的分发进行卸载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --unregister Ubuntu-20.04<br></code></pre></td></tr></table></figure><h3 id="然后将导出的文件放到需要保存的地方，进行导入"><a href="#然后将导出的文件放到需要保存的地方，进行导入" class="headerlink" title="然后将导出的文件放到需要保存的地方，进行导入"></a>然后将导出的文件放到需要保存的地方，进行导入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --import Ubuntu-20.04 F:\<span class="hljs-built_in">export</span>\ F:\export.tar --version 2<br></code></pre></td></tr></table></figure><h3 id="启动WSL并进入原来的user"><a href="#启动WSL并进入原来的user" class="headerlink" title="启动WSL并进入原来的user"></a>启动WSL并进入原来的user</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl<br>su jiangzixian<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>实践技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
